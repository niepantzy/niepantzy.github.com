---
layout:     post
title:     《Cocos2d-JS 开发之旅》学习笔记
subtitle:   cocos2d-js基础入门
date:       2019-04-02
author:     Niepan
header-img: img/cocos-bg.jpg
catalog: true
tags:
    - cocos2d
    - js
---

> 要开始学习前端知识，直接看线上业务代码三步一个坎，有JS语法的问题，也有Cocos API的问题，索性找来这本书。
>
> 本书比较适合前端小白，内容比较基础浅显，并且完全是以做一个游戏为目的展开的知识点教学，看完可以完成两个小但是完整的游戏，增强学习者的学习积极性。


# Cocos2d-JS介绍


cocos2d-x是一个支持多平台的2D手机游戏引擎，支持IOS、Android、winPhone等，cocos2d-js是cocos2d-x引擎的javascript版本，由cocos2d-x团队维护。它使用一组简化的JavaScript友好API支持完整的cocos2d-x功能。它包括两部分：cocos2d-HTML5和cocos2d-x JavaScript绑定（JSB），cocos2d-HTML5是一个纯的web JavaScript引擎，cocos2d-x JSB用于与cocos2d-HTML5共享相同API的本地应用程序。


Cocos2d-JS最大的优势就是强大的跨平台性，可以一次发布，同时实现H5游戏和原生手机游戏。同时他还有以下优点：

- 更高的开发效率
- JavaScript属于弱类型语言，语法灵活，入门简单
- 天然支持在线资源、脚本热更新

但是，Cocos2d-JS毕竟是脚本开发，跟cocos2d-x相比有两个天生的缺陷：

- JS脚本运行效率不及C++
- Cocos2d-JS的HTML5版本接口和原生接口有兼容性问题。这个就得自己踩坑了。

# 跑起我们的HelloWorld

#### Cocos2d-JS环境搭建


首先自然是要下载cocos2d-js的SDK,[cocos官网](https://cocos2d-x.org/download "官网")里现在已经把所有项目都整合到同一个包里。另外，官方把编译和部署的操作都打包成一个命令行工具：Cocos2d Console,我们可以很轻松的完成打包发布工作。

下载好SDK后解压到任意盘，然后下载其他依赖程序：python（Cocos2d Console基于python）、JDK、ant、Android SDK和Android NDK。全部安装好以后进入刚才解压的SDK目录，双击setup.py完成环境搭建。

开发IDE的话推荐WebStorm，可以很方便的配合Chrome浏览器调试代码。

#### 第一个程序 ：HelloWorld
打开命令行，切换到我们选择好的开发目录中。输入命令：

    cocos new -l js helloworld

其中：cocoss 是 Cocos2d Console的统一的命令入口，new表示新建一个项目 ， -l 表示后续的“js”s 我们需要建立的项目类型， helloworld是我们的项目名称。运行结束后，我们会看到以下画面：
![1.png](https://upload-images.jianshu.io/upload_images/1874051-2f28949c90229937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
此时在工作目录下可以看到helloworld文件夹，这就是一个cocos2d-js游戏项目了。使用WebStorm打开这个项目工程，展开左侧项目树，鼠标右击index.html，选择Open in Browser，再选择Chrome，我们就看到了期待已久的HelloWorld：
![2.png](https://upload-images.jianshu.io/upload_images/1874051-30e813f53ddd8d47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![3.png](https://upload-images.jianshu.io/upload_images/1874051-0fb778499d1782a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 项目结构树
打开HelloWorld目录，我们可以看到以下的目录结构：

![4.png](https://upload-images.jianshu.io/upload_images/1874051-ba18e94a3add8af8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)




| 目录 | 介绍 |
| :------| :------ |
| frameworks | 包含cocos2d-html5引擎、cocos2d-x引擎和各个平台的项目文件 |
| -cocos2d-html5 | cocos2d-html5引擎，用于让程序在浏览器上运行 |
| -cocos2d-x | 	cocos2d-x引擎 |
| -runtime-src | 各个平台的项目文件(android、ios、win) |
| res |	项目资源文件夹 |
| src |		项目代码文件夹 |
| index.html |	HTML5 基于web应用程序的入口点 |
| main.js |	游戏入口文件，包含游戏初始化代码及启动代码.由index.html加载 |
| project.json |	工程配置文件 |

main.js主要代码介绍：
```
//设置屏幕尺寸，最后一个参数是自适应类型，后面会具体介绍
cc.view.setDesignResolutionSize(960, 640, cc.ResolutionPolicy.SHOW_ALL);
//加载进入的场景
cc.LoaderScene.preload(g_resources, function () {
cc.director.runScene(new HelloWorldScene());
}, this);
```
project.json 各参数意义说明：
```
{
    "project_type": "javascript", //项目类型

    "debugMode" : 1, //表示程序的调试级别，0表示不输出任何调试信息，1表示输出全部信息，2表示只输出严重信息
    "showFPS" : true,// 表示是否在画面左下角显示当前的帧频信息
    "frameRate" : 60,//表示限制的最大帧频，如果设定为30，那么游戏最多1秒显示30帧
    "noCache" : false,
    "id" : "gameCanvas",//必需和index.html中的canvas标签id一致，便于JS程序查找canvas对象
    "renderMode" : 0,//渲染模式。0自动选择、1强制使用canvas渲染、2强制使用webGL渲染
    "engineDir":"frameworks/cocos2d-html5",//类库路径，调试时有用，发布后无用
    "modules" : ["cocos2d"],//本项目依赖的模块
    // 列出本项目所有需要加载的JS文件，JS会顺序加载这些文件，然后再调用main.js，需要特别注意这些文件的依赖关系和先后顺序
    "jsList" : [
        "src/resource.js",
        "src/app.js"
    ]
}

```

web项目的启动流程:

    index.html
    加载CCBoot.js
    读取 project.json
    加载 resource.js, app.js等project.json中列出的文件
    运行 main.js
    加载资源
    显示游戏

# Cocos2d-JS 语法

- 在JS中万物接对象，包括函数也是对象，所以函数也可以作为函数参数传入，因为习惯原因我传入函数的时候会**直接在后面加上括号，这样传入的就不是函数，而是调用函数后返回的结果了**。
- 类中定义属性和方法的时候约定私有的属性名前面加下划线“_name”，在程序中没有强制约束力。
- 对象中每个属性之间一定要用**逗号**分隔。
- cc：cc在cocos-js中是一个js对象，在这里起到命名空间的作用，所有的原生类型都封装在这个命名空间中
- extend函数： js中没有继承概念，这是cocos-js定义的一个继承函数，接收一个对象作为参数，可以扩展属性也可以重写父类方法：
- call/apply: 在JS中函数也是对象，系统为函数对象提供了apply和call两个方法。**任何函数都可以作为任何对象的方法来调用，即时这个函数不是那个对象的方法**，调用的对象通过方法的第一个参数指定，这是被调用的方法的this指向了这个对象。call方法第一个参数后的实参与被调用函数的实参一直，而apply方法第一个参数后被调用函数的参数以数组的形式出现。
- bind：JS给function增加了bind方法，bind会返回一个新的function，这个function执行的时候this将固定指向bind的第一个参数。这个方法在绑定事件处理函数或者定时器回调函数，如果**回调函数中使用 了this**的时候需要用到
```
//继承Scene
var MyScene = cc.Scene.extend({
    name:null,//扩展一个name属性
    //ctor是cocos2d-js中的构造函数名
    ctor:function (color,name) {
        this._super();//重写构造函数时，需要先调用父类的构造，不强制写在第一行
        var layer = new cc.Layer(color);
        this.addChild(layer);
        this.name = name;
    }
});

var scene =  new MyScene(cc.color(255,255,255),"niepan");
```


#### 需要特别注意的this

JavaScript中如果要在类中调用本对象内的任意方法或者属性都必须带this前缀，否则就会查找全局函数。
重要原则：this指向调用这个函数的对象。

```
var x = 1;
function test(){
     cc.log(this.x); 
}
test(); //1、这么调用的时候，函数的中this指向的是global对象

var o = {};
o.x = 1;
o.m = test;
o.m(); //2、这么调用的时候，函数的中this指向的是对象o.

var p = new test(); //3、使用new关键字调用function则会生成一个新的对象，this指向这个对象。
cc.log(p.x)

var o2 = {};
o2.x = 2;
o.m.apply(o2);
o.m.call(o2);//4、使用apply、call,函数中的this指向传入的第一个参数对象。

```


# Cocos2d-JS 基本元素

#### 场景（Scene）

 Cocos2d-JS 中把游戏界面拆分为多个场景，这样可以让游戏结构清晰，代码便于维护，并且有利于运行时的性能优化，场景切换时旧场景会被销毁，包含其中的图片文本都会被清除。
```
//定义场景
var HelloWorldScene = cc.Scene.extend({
    onEnter:function () {
        this._super();
        var layer = new HelloWorldLayer();
        this.addChild(layer);
    }
});
// 切换场景
cc.director.runScene(new HelloWorldScene());
```


#### 节点（Node）

节点是cocos2d中的最基础的东西，可以理解为java中的Object基类（不过在cocos中的基类是Class，node继承自它）。所有的显示类都继承与它。它封装了一些基本操作：缩放,坐标变化，缩放变化，透明度，可见性等。**其中有一个很重要的属性：children**，表示节点的孩子，节点包含子节点，子节点又可以包含子节点，类似一个树结构。这个属性的特性是：父节点的位置、大小、可见、透明度、旋转角度等属性变化的时候子节点会跟着一并变化。


#### 层（Layer）

层继承自节点，在实际中运用的最多，一个典型的游戏中往往包含这些层：背景层、人物层、道具层、系统信息层。各层之间互不干扰，各自管理自己的子节点，
```
//新建一个层
var layer = new cc.Layer();
//把层添加到场景上
scene.addChild(layer);
//再把子节点添加到这个层上
layer.addChild(child)
```
cocos2d-JS提供了两个常用的Layer：

- LayerColor ：纯色的背景层
```
//创建一个宽高都为100的纯白背景层，并添加到场景，宽高缺省时默认全屏
var layerColor = new cc.LayerColor(cc.color(255,255,255),100,100);
scene.addChild(layerColor);
```
- LayerGradient ： 颜色渐变的层
```
//创建一个由红色渐变为蓝色的背景
var layerGradient= new cc.LayerGradient(cc.color(255,0,0),cc.color(0,0,255));
scene.addChild(layerGradient);
```
- 除了cocos2d-JS提供的固定Layer，我们还可以通过继承自行扩展我们需要的层。

####  精灵（Sprite）


精灵也是从节点中扩展而来的，原始目的是用于表示游戏中的人物或NPC等，但实际中因为精灵封装了图片加载等功能，我们还可以用它来加载背景图，障碍物等非人物内容。精灵和层一样也可以包含子节点，可以跟进需求扩展自定义的精灵。
```
//创建一个指定图片的精灵
var ball= new cc.Sprite("res/ball.png");
this.addChild(ball);
// 获取窗口的设计尺寸
var size = cc.director.getWinSize();
//设置精灵的位置位于屏幕正中间
ball.x = size.width/2;
ball.y = size.height/2;
```


####  导演（Director）


在cocos2d-js中，导演指挥一切，场景与场景之间的切换就需要导演来完成：
```
cc.director.runScene(new HelloWorldScene());
// 传入TransitionSlideInT后可以让HelloWorldScene在2秒内从上往下进入场景，cocos2d-JS中的CCTransition.js提供了丰富的切换效果，比如TransitionMoveInB从下往上进入。
cc.director.fundScene(new cc.TransitionSlideInT(2,new HelloWorldScene()))
```
runScene会销毁旧场景上的所有内容，下次回到该场景时所有内容都需要重新建立 ，如果频繁的切换场景，我们可以使用pushScene和popScene，pushScene和runScene用法一样，但不会销毁场景而是缓存起来，popScene则是把当前场景销毁，快速回到上一个已缓存的场景。

导演还可以提供我们很多信息和功能：

- 窗口的设计尺寸：getWinSize
- 窗口的实际尺寸：getVisibleSize
- 获取全局的定时器：getScheduler
- 暂停/恢复场景：pause/resume


# 动起来

#### 帧

帧是动画或者影响的最基本的单位，每一帧就是一个画面，连续的多帧组合播放就是影像。帧频就是一秒内帧的数量，用fps(Frames per Second)表示，帧频越高，画面越流畅。一般电影为1秒24帧，游戏一般以69fps最为最高帧频，低于30fps的时候就会感觉不流畅。
cocos2d-JS中的projec.json 里的frameRate表示最大帧频，但是不一定真正能达到这个帧频，如果机器性能差就达不到这个需求。
在Node中提供了**scheduleUpdate和update**方法来满足我们每帧做指定事情的需求。
```
var layer = cc.Layer.extend({
      ctor:function(){
           this._super();
           this.scheduleUpdate();//通知当前节点每帧调用update函数
       },
       update:function(){
            cc.log("test"); //每帧打印一次
       }
})
```


#### 动作

节点有一个接口叫runAction，用来执行指定动作。只需要新建一个Action传个这个接口即可执行。
cocos2d-JS提供了一系列基础动作：

- 移动 moveTo(走到哪)/moveBy(走多远)

```
   var ball = new cc.Sprite("res/ball.png");
   var action = cc.moveTo(2,cc.p(100,200)); // 2秒内让小球移动至指定位置。
   ball.runAction(action);
   var action2 = cc.moveBy(2,cc.p(100,200)); // 2秒内让球x轴移动100，y轴移动200
```

- 缩放 ：scaleTo(以原图尺寸缩放)/scaleBy(以当前尺寸缩放)
*小技巧：设置节点的scaleX为-1 可以让图片水平翻转*

```
   var ball = new cc.Sprite("res/ball.png");
   var action = cc.scaleTo(2,3,3); // 2秒内让小球放大到原来的三倍
   ball.runAction(action);
   var action2 = cc.moveBy(2,3,3); // 2秒内让球放大到当前尺寸的三倍
   var action3 = cc.moveTo(1,-1,1); // 让图片水平翻转
```

-  淡入淡出： fadeTo(指定透明度)/fadeIn(淡入)/fadeOut(淡出)

```
   var action = cc.fadeTo(2,0); // 2秒内变透明，第二个参数为0-255透明度
   var action2 = cc.fadeOut(2); // 2秒内淡出
   var action3 = cc.fadeIn(2); // 2秒内淡入
```

-  闪烁： blink

```
   var action = cc.blink(2,10); // 2秒内闪烁10次

```

-  变色： tintTo

```
   var action = cc.blink(2,100,0,0); // 2秒内逐渐变为指定颜色。
    ball.color = cc.color(100,0,0);//上面的最终结果与这个一致。
```
-  延迟一段时间： delayTime
-  旋转： rotateTo/rotateBy
-  倾斜： skewTo/skewBy
-  跳跃： jumpTo/jumpBy
-  贝塞尔曲线移动： bezierTo/bezierBy

#### 组合动作

cocos2d-js 提供了五中组合基本动作的方式,这些组合方法返回的都是一个新的动作，然后将它传给runAction就可以运行了。

- 顺序（sequence） 
```
        var sequence1  = cc.sequence(action1,action2...);
        var action3 = cc.moveTo(2,200,200);
        var sequence2 = cc.sequence(sequence1,action3...);
        cc.runAction(sequence2);
```
- 重复（repeat） 
```
        cc.repeat(action,times);//第一个参为要重复的动作，第二个参数为重复次数。
        action.repeat(5);//动作本身也有repeat方法。
```
- 无限重复（repeatForever） 
```
        cc.repeatForever(action);
        action.repeatForever();//动作本身也有repeatForever方法。
```
- 同时执行（spawn） 
```
        cc.spawn(action1,action2...);
```
- 反向（reverseTime/reverse） 
```
        cc.reverseTime(action);
        action.reverse();//推荐使用这个
```

之前的动作都是匀速运动，并且运动轨迹都是直线。easing函数可以让动作缓动执行。支持很多缓动方式，这里只说两个，可以到CCActionEase.js中查找所有
```
      action.easing(easeObject);
      action.easing(cc.easeIn(2));//动作以2次方加速
      action.easing(cc.easeBounceIn());//弹性加速
      ....
```

#### 控制动作

```
      node.stopAction(action);//停止指定动作
      node.tag = 123;
      node.stopActionByTag(tag);//停止指定tag动作
      node.stopAllAction();//停止当前节点全部动作

      node.pause();//暂停节点动作
      node.resume();//恢复节点动作
      //上面只能操作当前节点的动作，不会影响其他节点，如果要统一做全局的暂停和恢复可以用上面说到的导演
       cc.director.pause();
       cc.director.resume();
```
Action没有提供直接的接口用于监听动作的开始和结束，但是有一个灵活的机制：**CallFunc**。CallFunc可以把一个普通函数封装成一个动作，再结合sequence我们就可以让一个动作结束后执行某个指定函数了

```
    // 第一个但是是某个函数，第二个参数是该函数最后被调用时的目标对象，第三个参数是额外附加的数据，调用函数的时候传过去。
    cc.callFunc(function,target,extra parameters ...);
```

#### 播放声音

背景音乐同时只能播一个，音效可以多个。
```
    //播放以及停止背景音乐。
    cc.audioEngine.playerMusic("res/bg.mp3",true); //第二个参数是指重复播放
    cc.audioEngine.stopMusic();

    //播放以及停止音效。
    var effect = cc.audioEngine.playerEffect("res/effect.mp3",true); //第二个参数是指重复播放
    cc.audioEngine.stopEffect(effect);//停止指定音效。
    cc.audioEngine.stopAllEffects();//停止全部音效

    //背景音乐和音效静音
     cc.audioEngine.setMusicVolume(0);
     cc.audioEngine.setEffectsVolume(0);
    
     //背景音乐和音效恢复音量
     cc.audioEngine.setMusicVolume(1);
     cc.audioEngine.setEffectsVolume(1);
```


# 操纵

#### 鼠标事件

使用cc.eventManager.addListener监听鼠标事件,这个函数接收两个参数，第一个是监听信息对象，第二个是监听的节点。
```
//不是所有平台都有鼠标事件，cc.sys.capabilities包含了当前平台的所有功能信息。
if("mouse" in cc.sys.capabilities){
    cc.eventManager.addListener({
           event:cc.EventListener.Mouse,      // 事件类型，event名字和类型都是固定的。
           onMouseDown:function(event){
                  //获取鼠标事件发生时的坐标 还有event.getLocationX()/event.getLocationY();
                   var pos = event.getLocation();
                   var target = event.getCurrentTarget(); //当前处理鼠标事件的对象，就是下面的第二个参数。
                   if(event.getButton == cc.EventMouse.BUTTON_RIGHT){//获取当前鼠标的键值。
                            cc.log("点了鼠标右键");
                    }
           }, 
           onMouseMove:function(event){
                   // 移动事件中才有效，表示移动的偏移值，还有event.getDeltaX()/event.getDeltaY()
                    var delta = event.getDelta();
           },
           onMouseUp:function(event){}
           
     },node)
}
   
```

#### 触摸事件

```
if("touches" in cc.sys.capabilities){
    cc.eventManager.addListener({
           event:cc.EventListener.TOUCH_ONE_BY_ONE,      // 单点触摸事件
          // event:cc.EventListener.TOUCH_ALL_AT_ONCE,      // 多点触摸事件
           onTouchBegan:function(touch，event){
                 var pos = touch.getLocation(); //触摸位置
                 var id = touch.getID();  //触摸id，主要用于多点触摸中不同的触点
                  
           },//触摸开始
            //触摸移动，这里假定是监听的多点触摸。参数变成了touches
           onTouchMoved:function(touches，event){
                for(var i = 0;i<touches.length;i++){
                       var touche = touches[i];
                 }
           },
           onTouchEnded:function(){},//触摸结束
           //触摸取消，这个是指触摸过程中被电话或者其他程序干预，一般不会触发，开发中一般按结束等同处理。
           onTouchCancelled:function(){}
     },node)
}
   
```


#### 键盘事件

```
if("keyboard" in cc.sys.capabilities){
    cc.eventManager.addListener({
           event:cc.EventListener.KEYBOARD,      // 键盘事件
           onKeyReleased:function(keyCode,event){
                  if(keyCode == cc.KEY.back){
                          //keyCode是一个数字，代表不同的键值，具体可以查看cc.KEY;
                  }
           }
     },node)
}
   
```

#### 重力感应事件

event:cc.EventListener.ACCELERATION

#### 进入后台/恢复显示事件

cocos2d-js提供了对这两个事件的处理，如果我们需要做一些额外的操作比如报存游戏进度等，可以监听这两个事件。
```
     //游戏进入后台
     cc.eventManager.addCustomListener(cc.game.EVENT_HIDE,function(){});
      //游戏恢复显示
     cc.eventManager.addCustomListener(cc.game.EVENT_SHOW,function(){});
```

# 定时器
scheduleUpdate、scheduleOnce、schedule是cocos提供的三个定时器，他们都依赖于节点。

#### scheduleUpdate

这个定时器我们上面已经提到过了。通过他可以让游戏在运行过程中每帧都执行一次update方法。


#### scheduleOnce

用来替代setTimeout。
```
    node.scheduleOnce(callback,delay);//时间单位是秒
```

#### schedule

实现固定时间间隔不断触发指定函数。
```
   //第二个参数是触发间隔（秒），第三个是重复的次数，实际会执行repeat + 1次 cc.REPEAT_FOREVER 为无限循环常量。第四个参表示第一次触发的延迟时间（秒）
    node.schedule(callback,inverval,repeat,delay);
```

#### 取消定时器
- 取消scheduleUpdate用node.unscheduleUpdate();
- 取消scheduleOnce和schedule都用node.unschedule(callback),callback必须和原来传入的函数一致。

#### 暂停恢复定时器
node.pause()     node.resume();

# 界面

#### 按钮（MenuItem）
MenuItem 提供了最基本的按钮功能-点击后的回调处理。
Cocos2d-JS 提供了四种按钮：
- MenuItemSprite： 继承自MenuItem，增加了界面，也就是带图的按钮。
```
     //spriteNormal正常状态的效果，spriteSelected按下的效果，spriteDisble禁用的效果，clickHandler回调函数。target是作用于clickHandler的target对象。spriteDisble、target可以缺省。
var menuSprite =  new cc.MenuItemSprite（spriteNormal,spriteSelected,spriteDisble,clickHandler,target）
// 禁用按钮
menuSprite.setEnabled(false);
   
```

- MenuItemImage： 继承自MenuItemSprite，目的是使加载图片的操作更顺利，省去了中间要新建几个Sprite的麻烦，用法与MenuItemSprite几乎一致，唯一的区别就是sprite换成了图片的url。
```
new cc.MenuItemImage（imageNormalUrl,imageSelectedUrl,imageDisbleUrl,clickHandler,target）   
```


- MenuItemFont： 继承自MenuItem，除了以图片作为按钮以外还可以用文字作为按钮，就是丑
```
 var menuFont = new cc.MenuItemFont（text,clickHandler,target）   ;
 menuFont.fontSize = 32; //字体大小
 menuFont.foneName = "Arial"; //字体
 //可以直接统一设置字体，设置全局字体后，后续新建的MenuItemFont都使用这个字体，可以单独修改自己的。
 cc.MenuItemFont.setFontName("Arial");
 cc.MenuItemFont.setFontSize(32);
```

- MenuItemLabel： 继承自MenuItem，也是字，不过比MenuItemFont用系统字好一些，可以用位图文字。
```
new cc.MenuItemLabel（ttf/bnfont,clickHandler,target）   ;
```

#### 开关按钮（MenuItemToggle）

静音按钮就是一个很好的例子，点击后不同状态显示的图片不一样。MenuItemToggle接收多个MenuItem，每次点击后切换到下一个MenuItem，一直循环切换。
```
       var on = new cc.MenuItemFont("ON");
       var off = new cc.MenuItemFont("OFF");
       var item = new MenuItemToggle(on,off,this.xxxx,this);
```

#### 菜单（Menu）

上面讲到的所有按钮都必须添加到Menu里才能成为真正的按钮,可以理解为按钮的容器，不添加到Menu里的按钮是不可以接收点击事件的。Menu可以接收多个按钮。
```
var menuFont1 = new cc.MenuItemFont("test");
var menuFont2 = new cc.MenuItemFont("test");
var menu = new cc.Menu(menuFont1,menuFont2);
menu.alignItemsVertically();// 所有按钮纵向排列
menu.alignItemsHorizontally();// 所有按钮横向排列
menu.alignItemsHorizontallyWithPadding(10);// 所有按钮横向排列，间隔20

```

#### 文本（LabelTTF）


```
//文字、字体、字体大小、文字标签的占位大小、横向对齐方式、纵向对齐方式
new cc.LabelTTF(text,font,fontSize,labelSize,hAlign,vAlign)
```
#### 使用CocosStudio导出的UI文件
CocosStudio导出的UI文件为图片文件以及一个JSON文件，JSON文件中记录了UI信息。
代码中使用编辑好的UI文件：
```
    var root = ccs.uiReader.widgetFromJsonFile("res/testui.json");
    this.addChild(root);
    //根据ui中定义的tag查找指定控件
    var  button = ccui.helper.seekWidgetByTag(root,30);
    //根据ui中定义的控件名查找指定控件
    var checkBox = ccui.helper.seekWidgetByName(root,"CheckBox_1");

    //添加监听事件比之前简单，只要一句话
    button.addClickEventListener(callBackFunc);
    button.addTouchEventListener(callBackFunc,target);
```
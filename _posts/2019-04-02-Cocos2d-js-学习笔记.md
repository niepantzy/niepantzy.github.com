---
layout:     post
title:     《Cocos2d-JS 开发之旅》学习笔记
subtitle:   cocos2d-js基础入门
date:       2019-04-02
author:     Niepan
header-img: img/cocos-bg.jpg
catalog: true
tags:
    - cocos2d
    - js
---

> 要开始学习前端知识，直接看线上业务代码三步一个坎，有JS语法的问题，也有Cocos API的问题，索性找来这本书。
>
> 本书比较适合前端小白，内容比较基础浅显，并且完全是以做一个游戏为目的展开的知识点教学，看完可以完成两个小但是完整的游戏，增强学习者的学习积极性。


# Cocos2d-JS介绍


cocos2d-x是一个支持多平台的2D手机游戏引擎，支持IOS、Android、winPhone等，cocos2d-js是cocos2d-x引擎的javascript版本，由cocos2d-x团队维护。它使用一组简化的JavaScript友好API支持完整的cocos2d-x功能。它包括两部分：cocos2d-HTML5和cocos2d-x JavaScript绑定（JSB），cocos2d-HTML5是一个纯的web JavaScript引擎，cocos2d-x JSB用于与cocos2d-HTML5共享相同API的本地应用程序。


Cocos2d-JS最大的优势就是强大的跨平台性，可以一次发布，同时实现H5游戏和原生手机游戏。同时他还有以下优点：

- 更高的开发效率
- JavaScript属于弱类型语言，语法灵活，入门简单
- 天然支持在线资源、脚本热更新

但是，Cocos2d-JS毕竟是脚本开发，跟cocos2d-x相比有两个天生的缺陷：

- JS脚本运行效率不及C++
- Cocos2d-JS的HTML5版本接口和原生接口有兼容性问题。这个就得自己踩坑了。

# 跑起我们的HelloWorld

#### Cocos2d-JS环境搭建


首先自然是要下载cocos2d-js的SDK,[cocos官网](https://cocos2d-x.org/download "官网")里现在已经把所有项目都整合到同一个包里。另外，官方把编译和部署的操作都打包成一个命令行工具：Cocos2d Console,我们可以很轻松的完成打包发布工作。

下载好SDK后解压到任意盘，然后下载其他依赖程序：python（Cocos2d Console基于python）、JDK、ant、Android SDK和Android NDK。全部安装好以后进入刚才解压的SDK目录，双击setup.py完成环境搭建。

开发IDE的话推荐WebStorm，可以很方便的配合Chrome浏览器调试代码。

#### 第一个程序 ：HelloWorld
打开命令行，切换到我们选择好的开发目录中。输入命令：

    cocos new -l js helloworld

其中：cocoss 是 Cocos2d Console的统一的命令入口，new表示新建一个项目 ， -l 表示后续的“js”s 我们需要建立的项目类型， helloworld是我们的项目名称。运行结束后，我们会看到以下画面：
![1.png](https://upload-images.jianshu.io/upload_images/1874051-2f28949c90229937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
此时在工作目录下可以看到helloworld文件夹，这就是一个cocos2d-js游戏项目了。使用WebStorm打开这个项目工程，展开左侧项目树，鼠标右击index.html，选择Open in Browser，再选择Chrome，我们就看到了期待已久的HelloWorld：
![2.png](https://upload-images.jianshu.io/upload_images/1874051-30e813f53ddd8d47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![3.png](https://upload-images.jianshu.io/upload_images/1874051-0fb778499d1782a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 项目结构树
打开HelloWorld目录，我们可以看到以下的目录结构：

![4.png](https://upload-images.jianshu.io/upload_images/1874051-ba18e94a3add8af8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)




| 目录 | 介绍 |
| :------| :------ |
| frameworks | 包含cocos2d-html5引擎、cocos2d-x引擎和各个平台的项目文件 |
| -cocos2d-html5 | cocos2d-html5引擎，用于让程序在浏览器上运行 |
| -cocos2d-x | 	cocos2d-x引擎 |
| -runtime-src | 各个平台的项目文件(android、ios、win) |
| res |	项目资源文件夹 |
| src |		项目代码文件夹 |
| index.html |	HTML5 基于web应用程序的入口点 |
| main.js |	游戏入口文件，包含游戏初始化代码及启动代码.由index.html加载 |
| project.json |	工程配置文件 |

main.js主要代码介绍：
```
//设置屏幕尺寸，最后一个参数是自适应类型，后面会具体介绍
cc.view.setDesignResolutionSize(960, 640, cc.ResolutionPolicy.SHOW_ALL);
//加载进入的场景
cc.LoaderScene.preload(g_resources, function () {
cc.director.runScene(new HelloWorldScene());
}, this);
```
project.json 各参数意义说明：
```
{
    "project_type": "javascript", //项目类型

    "debugMode" : 1, //表示程序的调试级别，0表示不输出任何调试信息，1表示输出全部信息，2表示只输出严重信息
    "showFPS" : true,// 表示是否在画面左下角显示当前的帧频信息
    "frameRate" : 60,//表示限制的最大帧频，如果设定为30，那么游戏最多1秒显示30帧
    "noCache" : false,
    "id" : "gameCanvas",//必需和index.html中的canvas标签id一致，便于JS程序查找canvas对象
    "renderMode" : 0,//渲染模式。0自动选择、1强制使用canvas渲染、2强制使用webGL渲染
    "engineDir":"frameworks/cocos2d-html5",//类库路径，调试时有用，发布后无用
    "modules" : ["cocos2d"],//本项目依赖的模块
    // 列出本项目所有需要加载的JS文件，JS会顺序加载这些文件，然后再调用main.js，需要特别注意这些文件的依赖关系和先后顺序
    "jsList" : [
        "src/resource.js",
        "src/app.js"
    ]
}

```

web项目的启动流程:

    index.html
    加载CCBoot.js
    读取 project.json
    加载 resource.js, app.js等project.json中列出的文件
    运行 main.js
    加载资源
    显示游戏

# Cocos2d-JS 语法

- 在JS中万物接对象，包括函数也是对象，所以函数也可以作为函数参数传入，因为习惯原因我传入函数的时候会**直接在后面加上括号，这样传入的就不是函数，而是调用函数后返回的结果了**。
- 类中定义属性和方法的时候约定私有的属性名前面加下划线“_name”，在程序中没有强制约束力。
- 对象中每个属性之间一定要用**逗号**分隔。
- cc：cc在cocos-js中是一个js对象，在这里起到命名空间的作用，所有的原生类型都封装在这个命名空间中
- extend函数： js中没有继承概念，这是cocos-js定义的一个继承函数，接收一个对象作为参数，可以扩展属性也可以重写父类方法：
- call/apply: 在JS中函数也是对象，系统为函数对象提供了apply和call两个方法。**任何函数都可以作为任何对象的方法来调用，即时这个函数不是那个对象的方法**，调用的对象通过方法的第一个参数指定，这是被调用的方法的this指向了这个对象。call方法第一个参数后的实参与被调用函数的实参一直，而apply方法第一个参数后被调用函数的参数以数组的形式出现。
- bind：JS给function增加了bind方法，bind会返回一个新的function，这个function执行的时候this将固定指向bind的第一个参数。这个方法在绑定事件处理函数或者定时器回调函数，如果**回调函数中使用 了this**的时候需要用到
```
//继承Scene
var MyScene = cc.Scene.extend({
    name:null,//扩展一个name属性
    //ctor是cocos2d-js中的构造函数名
    ctor:function (color,name) {
        this._super();//重写构造函数时，需要先调用父类的构造，不强制写在第一行
        var layer = new cc.Layer(color);
        this.addChild(layer);
        this.name = name;
    }
});

var scene =  new MyScene(cc.color(255,255,255),"niepan");
```

#### 需要特别注意的this
JavaScript中如果要在类中调用本对象内的任意方法或者属性都必须带this前缀，否则就会查找全局函数。
重要原则：this指向调用这个函数的对象。

```
var x = 1;
function test(){
     cc.log(this.x); 
}
test(); //1、这么调用的时候，函数的中this指向的是global对象

var o = {};
o.x = 1;
o.m = test;
o.m(); //2、这么调用的时候，函数的中this指向的是对象o.

var p = new test(); //3、使用new关键字调用function则会生成一个新的对象，this指向这个对象。
cc.log(p.x)

var o2 = {};
o2.x = 2;
o.m.apply(o2);
o.m.call(o2);//4、使用apply、call,函数中的this指向传入的第一个参数对象。

```

# Cocos2d-JS 基本元素
#### 场景（Scene）
 Cocos2d-JS 中把游戏界面拆分为多个场景，这样可以让游戏结构清晰，代码便于维护，并且有利于运行时的性能优化，场景切换时旧场景会被销毁，包含其中的图片文本都会被清除。
```
//定义场景
var HelloWorldScene = cc.Scene.extend({
    onEnter:function () {
        this._super();
        var layer = new HelloWorldLayer();
        this.addChild(layer);
    }
});
// 切换场景
cc.director.runScene(new HelloWorldScene());
```

#### 节点（Node）

节点是cocos2d中的最基础的东西，可以理解为java中的Object基类（不过在cocos中的基类是Class，node继承自它）。所有的显示类都继承与它。它封装了一些基本操作：缩放,坐标变化，缩放变化，透明度，可见性等。**其中有一个很重要的属性：children**，表示节点的孩子，节点包含子节点，子节点又可以包含子节点，类似一个树结构。这个属性的特性是：父节点的位置、大小、可见、透明度、旋转角度等属性变化的时候子节点会跟着一并变化。

#### 层（Layer）
层继承自节点，在实际中运用的最多，一个典型的游戏中往往包含这些层：背景层、人物层、道具层、系统信息层。各层之间互不干扰，各自管理自己的子节点，
```
//新建一个层
var layer = new cc.Layer();
//把层添加到场景上
scene.addChild(layer);
//再把子节点添加到这个层上
layer.addChild(child)
```
cocos2d-JS提供了两个常用的Layer：

- LayerColor ：纯色的背景层
```
//创建一个宽高都为100的纯白背景层，并添加到场景，宽高缺省时默认全屏
var layerColor = new cc.LayerColor(cc.color(255,255,255),100,100);
scene.addChild(layerColor);
```
- LayerGradient ： 颜色渐变的层
```
//创建一个由红色渐变为蓝色的背景
var layerGradient= new cc.LayerGradient(cc.color(255,0,0),cc.color(0,0,255));
scene.addChild(layerGradient);
```
- 除了cocos2d-JS提供的固定Layer，我们还可以通过继承自行扩展我们需要的层。
####  精灵（Sprite）
精灵也是从节点中扩展而来的，原始目的是用于表示游戏中的人物或NPC等，但实际中因为精灵封装了图片加载等功能，我们还可以用它来加载背景图，障碍物等非人物内容。精灵和层一样也可以包含子节点，可以跟进需求扩展自定义的精灵。
```
//创建一个指定图片的精灵
var ball= new cc.Sprite("res/ball.png");
this.addChild(ball);
// 获取窗口的设计尺寸
var size = cc.director.getWinSize();
//设置精灵的位置位于屏幕正中间
ball.x = size.width/2;
ball.y = size.height/2;
```

####  导演（Director）
在cocos2d-js中，导演指挥一切，场景与场景之间的切换就需要导演来完成：
```
cc.director.runScene(new HelloWorldScene());
// 传入TransitionSlideInT后可以让HelloWorldScene在2秒内从上往下进入场景，cocos2d-JS中的CCTransition.js提供了丰富的切换效果，比如TransitionMoveInB从下往上进入。
cc.director.fundScene(new cc.TransitionSlideInT(2,new HelloWorldScene()))
```
runScene会销毁旧场景上的所有内容，下次回到该场景时所有内容都需要重新建立 ，如果频繁的切换场景，我们可以使用pushScene和popScene，pushScene和runScene用法一样，但不会销毁场景而是缓存起来，popScene则是把当前场景销毁，快速回到上一个已缓存的场景。

导演还可以提供我们很多信息和功能：

- 窗口的设计尺寸：getWinSize
- 窗口的实际尺寸：getVisibleSize
- 获取全局的定时器：getScheduler
- 暂停/恢复场景：pause/resume


# 动起来
#### 帧
帧是动画或者影响的最基本的单位，每一帧就是一个画面，连续的多帧组合播放就是影像。帧频就是一秒内帧的数量，用fps(Frames per Second)表示，帧频越高，画面越流畅。一般电影为1秒24帧，游戏一般以69fps最为最高帧频，低于30fps的时候就会感觉不流畅。
cocos2d-JS中的projec.json 里的frameRate表示最大帧频，但是不一定真正能达到这个帧频，如果机器性能差就达不到这个需求。
在Node中提供了**scheduleUpdate和update**方法来满足我们每帧做指定事情的需求。
```
var layer = cc.Layer.extend({
      ctor:function(){
           this._super();
           this.scheduleUpdate();//通知当前节点每帧调用update函数
       },
       update:function(){
            cc.log("test"); //每帧打印一次
       }
})
```

#### 动作

